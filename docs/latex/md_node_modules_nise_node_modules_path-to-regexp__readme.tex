\begin{quote}
Turn an Express-\/style path string such as {\ttfamily /user/\+:name} into a regular expression. \end{quote}


\href{https://npmjs.org/package/path-to-regexp}{\tt } \href{https://travis-ci.org/pillarjs/path-to-regexp}{\tt } \href{https://coveralls.io/r/pillarjs/path-to-regexp?branch=master}{\tt } \href{https://david-dm.org/pillarjs/path-to-regexp}{\tt } !\mbox{[}License\mbox{]}\mbox{[}license-\/image\mbox{]} \href{https://npmjs.org/package/path-to-regexp}{\tt }

\subsection*{Installation}


\begin{DoxyCode}
npm install path-to-regexp --save
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var pathToRegexp = require('path-to-regexp')

// pathToRegexp(path, keys, options)
// pathToRegexp.parse(path)
// pathToRegexp.compile(path)
\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries path} An Express-\/style string, an array of strings, or a regular expression.
\item {\bfseries keys} An array to be populated with the keys found in the path.
\item {\bfseries options}
\begin{DoxyItemize}
\item {\bfseries sensitive} When {\ttfamily true} the route will be case sensitive. (default\+: {\ttfamily false})
\item {\bfseries strict} When {\ttfamily false} the trailing slash is optional. (default\+: {\ttfamily false})
\item {\bfseries end} When {\ttfamily false} the path will match at the beginning. (default\+: {\ttfamily true})
\item {\bfseries delimiter} Set the default delimiter for repeat parameters. (default\+: `'/\textquotesingle{}\`{})
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}
var keys = []
var re = pathToRegexp('/foo/:bar', keys)
// re = /^\(\backslash\)/foo\(\backslash\)/([^\(\backslash\)/]+?)\(\backslash\)/?$/i
// keys = [\{ name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\(\backslash\)\(\backslash\)/]+?'
       \}]
\end{DoxyCode}


{\bfseries Please note\+:} The {\ttfamily Reg\+Exp} returned by {\ttfamily path-\/to-\/regexp} is intended for use with pathnames or hostnames. It can not handle the query strings or fragments of a U\+RL.

\subsubsection*{Parameters}

The path string can be used to define parameters and populate the keys.

\paragraph*{Named Parameters}

Named parameters are defined by prefixing a colon to the parameter name ({\ttfamily \+:foo}). By default, the parameter will match until the following path segment.


\begin{DoxyCode}
var re = pathToRegexp('/:foo/:bar', keys)
// keys = [\{ name: 'foo', prefix: '/', ... \}, \{ name: 'bar', prefix: '/', ... \}]

re.exec('/test/route')
//=> ['/test/route', 'test', 'route']
\end{DoxyCode}


{\bfseries Please note\+:} Named parameters must be made up of \char`\"{}word characters\char`\"{} ({\ttfamily \mbox{[}A-\/\+Za-\/z0-\/9\+\_\+\mbox{]}}).


\begin{DoxyCode}
var re = pathToRegexp('/(apple-)?icon-:res(\(\backslash\)\(\backslash\)d+).png', keys)
// keys = [\{ name: 0, prefix: '/', ... \}, \{ name: 'res', prefix: '', ... \}]

re.exec('/icon-76.png')
//=> ['/icon-76.png', undefined, '76']
\end{DoxyCode}


\paragraph*{Modified Parameters}

\subparagraph*{Optional}

Parameters can be suffixed with a question mark ({\ttfamily ?}) to make the parameter optional. This will also make the prefix optional.


\begin{DoxyCode}
var re = pathToRegexp('/:foo/:bar?', keys)
// keys = [\{ name: 'foo', ... \}, \{ name: 'bar', delimiter: '/', optional: true, repeat: false \}]

re.exec('/test')
//=> ['/test', 'test', undefined]

re.exec('/test/route')
//=> ['/test', 'test', 'route']
\end{DoxyCode}


\subparagraph*{Zero or more}

Parameters can be suffixed with an asterisk ({\ttfamily $\ast$}) to denote a zero or more parameter matches. The prefix is taken into account for each match.


\begin{DoxyCode}
var re = pathToRegexp('/:foo*', keys)
// keys = [\{ name: 'foo', delimiter: '/', optional: true, repeat: true \}]

re.exec('/')
//=> ['/', undefined]

re.exec('/bar/baz')
//=> ['/bar/baz', 'bar/baz']
\end{DoxyCode}


\subparagraph*{One or more}

Parameters can be suffixed with a plus sign ({\ttfamily +}) to denote a one or more parameter matches. The prefix is taken into account for each match.


\begin{DoxyCode}
var re = pathToRegexp('/:foo+', keys)
// keys = [\{ name: 'foo', delimiter: '/', optional: false, repeat: true \}]

re.exec('/')
//=> null

re.exec('/bar/baz')
//=> ['/bar/baz', 'bar/baz']
\end{DoxyCode}


\paragraph*{Custom Match Parameters}

All parameters can be provided a custom regexp, which overrides the default ({\ttfamily \mbox{[}$^\wedge$\textbackslash{}/\mbox{]}+}).


\begin{DoxyCode}
var re = pathToRegexp('/:foo(\(\backslash\)\(\backslash\)d+)', keys)
// keys = [\{ name: 'foo', ... \}]

re.exec('/123')
//=> ['/123', '123']

re.exec('/abc')
//=> null
\end{DoxyCode}


{\bfseries Please note\+:} Backslashes need to be escaped with another backslash in strings.

\paragraph*{Unnamed Parameters}

It is possible to write an unnamed parameter that only consists of a matching group. It works the same as a named parameter, except it will be numerically indexed.


\begin{DoxyCode}
var re = pathToRegexp('/:foo/(.*)', keys)
// keys = [\{ name: 'foo', ... \}, \{ name: 0, ... \}]

re.exec('/test/route')
//=> ['/test/route', 'test', 'route']
\end{DoxyCode}


\paragraph*{Asterisk}

An asterisk can be used for matching everything. It is equivalent to an unnamed matching group of {\ttfamily (.$\ast$)}.


\begin{DoxyCode}
var re = pathToRegexp('/foo/*', keys)
// keys = [\{ name: '0', ... \}]

re.exec('/foo/bar/baz')
//=> ['/foo/bar/baz', 'bar/baz']
\end{DoxyCode}


\subsubsection*{Parse}

The parse function is exposed via {\ttfamily path\+To\+Regexp.\+parse}. This will return an array of strings and keys.


\begin{DoxyCode}
var tokens = pathToRegexp.parse('/route/:foo/(.*)')

console.log(tokens[0])
//=> "/route"

console.log(tokens[1])
//=> \{ name: 'foo', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\(\backslash\)\(\backslash\)/]+?' \}

console.log(tokens[2])
//=> \{ name: 0, prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '.*' \}
\end{DoxyCode}


{\bfseries Note\+:} This method only works with Express-\/style strings.

\subsubsection*{Compile (\char`\"{}\+Reverse\char`\"{} Path-\/\+To-\/\+Reg\+Exp)}

Path-\/\+To-\/\+Reg\+Exp exposes a compile function for transforming an Express-\/style path into a valid path.


\begin{DoxyCode}
var toPath = pathToRegexp.compile('/user/:id')

toPath(\{ id: 123 \}) //=> "/user/123"
toPath(\{ id: 'cafÃ©' \}) //=> "/user/caf%C3%A9"
toPath(\{ id: '/' \}) //=> "/user/%2F"

toPath(\{ id: ':' \}) //=> "/user/%3A"
toPath(\{ id: ':' \}, \{ pretty: true \}) //=> "/user/:"

var toPathRepeated = pathToRegexp.compile('/:segment+')

toPathRepeated(\{ segment: 'foo' \}) //=> "/foo"
toPathRepeated(\{ segment: ['a', 'b', 'c'] \}) //=> "/a/b/c"

var toPathRegexp = pathToRegexp.compile('/user/:id(\(\backslash\)\(\backslash\)d+)')

toPathRegexp(\{ id: 123 \}) //=> "/user/123"
toPathRegexp(\{ id: '123' \}) //=> "/user/123"
toPathRegexp(\{ id: 'abc' \}) //=> Throws `TypeError`.
\end{DoxyCode}


{\bfseries Note\+:} The generated function will throw on invalid input. It will do all necessary checks to ensure the generated path is valid. This method only works with strings.

\subsubsection*{Working with Tokens}

Path-\/\+To-\/\+Reg\+Exp exposes the two functions used internally that accept an array of tokens.


\begin{DoxyItemize}
\item {\ttfamily path\+To\+Regexp.\+tokens\+To\+Reg\+Exp(tokens, options)} Transform an array of tokens into a matching regular expression.
\item {\ttfamily path\+To\+Regexp.\+tokens\+To\+Function(tokens)} Transform an array of tokens into a path generator function.
\end{DoxyItemize}

\paragraph*{Token Information}


\begin{DoxyItemize}
\item {\ttfamily name} The name of the token ({\ttfamily string} for named or {\ttfamily number} for index)
\item {\ttfamily prefix} The prefix character for the segment ({\ttfamily /} or {\ttfamily .})
\item {\ttfamily delimiter} The delimiter for the segment (same as prefix or {\ttfamily /})
\item {\ttfamily optional} Indicates the token is optional ({\ttfamily boolean})
\item {\ttfamily repeat} Indicates the token is repeated ({\ttfamily boolean})
\item {\ttfamily partial} Indicates this token is a partial path segment ({\ttfamily boolean})
\item {\ttfamily pattern} The Reg\+Exp used to match this token ({\ttfamily string})
\item {\ttfamily asterisk} Indicates the token is an {\ttfamily $\ast$} match ({\ttfamily boolean})
\end{DoxyItemize}

\subsection*{Compatibility with Express $<$= 4.\+x}

Path-\/\+To-\/\+Reg\+Exp breaks compatibility with Express $<$= {\ttfamily 4.\+x}\+:


\begin{DoxyItemize}
\item No longer a direct conversion to a Reg\+Exp with sugar on top -\/ it\textquotesingle{}s a path matcher with named and unnamed matching groups
\begin{DoxyItemize}
\item It\textquotesingle{}s unlikely you previously abused this feature, it\textquotesingle{}s rare and you could always use a Reg\+Exp instead
\end{DoxyItemize}
\item All matching Reg\+Exp special characters can be used in a matching group. E.\+g. {\ttfamily /\+:user(.$\ast$)}
\begin{DoxyItemize}
\item Other Reg\+Exp features are not support -\/ no nested matching groups, non-\/capturing groups or look aheads
\end{DoxyItemize}
\item Parameters have suffixes that augment meaning -\/ {\ttfamily $\ast$}, {\ttfamily +} and {\ttfamily ?}. E.\+g. {\ttfamily /\+:user$\ast$}
\end{DoxyItemize}

\subsection*{Type\+Script}

Includes a \href{index.d.ts}{\tt {\ttfamily .d.\+ts}} file for Type\+Script users.

\subsection*{Live Demo}

You can see a live demo of this library in use at \href{http://forbeslindesay.github.com/express-route-tester/}{\tt express-\/route-\/tester}.

\subsection*{License}

M\+IT 