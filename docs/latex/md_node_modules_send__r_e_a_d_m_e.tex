\href{https://npmjs.org/package/send}{\tt } \href{https://npmjs.org/package/send}{\tt } \href{https://travis-ci.org/pillarjs/send}{\tt } \href{https://ci.appveyor.com/project/dougwilson/send}{\tt } \href{https://coveralls.io/r/pillarjs/send?branch=master}{\tt }

Send is a library for streaming files from the file system as a http response supporting partial responses (Ranges), conditional-\/\+G\+ET negotiation (If-\/\+Match, If-\/\+Unmodified-\/\+Since, If-\/\+None-\/\+Match, If-\/\+Modified-\/\+Since), high test coverage, and granular events which may be leveraged to take appropriate actions in your application or framework.

Looking to serve up entire folders mapped to U\+R\+Ls? Try \href{https://www.npmjs.org/package/serve-static}{\tt serve-\/static}.

\subsection*{Installation}

This is a \href{https://nodejs.org/en/}{\tt Node.\+js} module available through the \href{https://www.npmjs.com/}{\tt npm registry}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\tt {\ttfamily npm install} command}\+:


\begin{DoxyCode}
$ npm install send
\end{DoxyCode}


\subsection*{A\+PI}


\begin{DoxyCode}
var send = require('send')
\end{DoxyCode}


\subsubsection*{send(req, path, \mbox{[}options\mbox{]})}

Create a new {\ttfamily Send\+Stream} for the given path to send to a {\ttfamily res}. The {\ttfamily req} is the Node.\+js H\+T\+TP request and the {\ttfamily path} is a urlencoded path to send (urlencoded, not the actual file-\/system path).

\paragraph*{Options}

\subparagraph*{accept\+Ranges}

Enable or disable accepting ranged requests, defaults to true. Disabling this will not send {\ttfamily Accept-\/\+Ranges} and ignore the contents of the {\ttfamily Range} request header.

\subparagraph*{cache\+Control}

Enable or disable setting {\ttfamily Cache-\/\+Control} response header, defaults to true. Disabling this will ignore the {\ttfamily immutable} and {\ttfamily max\+Age} options.

\subparagraph*{dotfiles}

Set how \char`\"{}dotfiles\char`\"{} are treated when encountered. A dotfile is a file or directory that begins with a dot (\char`\"{}.\char`\"{}). Note this check is done on the path itself without checking if the path actually exists on the disk. If {\ttfamily root} is specified, only the dotfiles above the root are checked (i.\+e. the root itself can be within a dotfile when when set to \char`\"{}deny\char`\"{}).


\begin{DoxyItemize}
\item `\textquotesingle{}allow'{\ttfamily No special treatment for dotfiles. -\/}\textquotesingle{}deny\textquotesingle{}{\ttfamily Send a 403 for any request for a dotfile. -\/}\textquotesingle{}ignore\textquotesingle{}\`{} Pretend like the dotfile does not exist and 404.
\end{DoxyItemize}

The default value is {\itshape similar} to `\textquotesingle{}ignore'\`{}, with the exception that this default will not ignore the files within a directory that begins with a dot, for backward-\/compatibility.

\subparagraph*{end}

Byte offset at which the stream ends, defaults to the length of the file minus 1. The end is inclusive in the stream, meaning {\ttfamily end\+: 3} will include the 4th byte in the stream.

\subparagraph*{etag}

Enable or disable etag generation, defaults to true.

\subparagraph*{extensions}

If a given file doesn\textquotesingle{}t exist, try appending one of the given extensions, in the given order. By default, this is disabled (set to {\ttfamily false}). An example value that will serve extension-\/less H\+T\+ML files\+: `\mbox{[}\textquotesingle{}html', \textquotesingle{}htm\textquotesingle{}\mbox{]}\`{}. This is skipped if the requested file already has an extension.

\subparagraph*{immutable}

Enable or diable the {\ttfamily immutable} directive in the {\ttfamily Cache-\/\+Control} response header, defaults to {\ttfamily false}. If set to {\ttfamily true}, the {\ttfamily max\+Age} option should also be specified to enable caching. The {\ttfamily immutable} directive will prevent supported clients from making conditional requests during the life of the {\ttfamily max\+Age} option to check if the file has changed.

\subparagraph*{index}

By default send supports \char`\"{}index.\+html\char`\"{} files, to disable this set {\ttfamily false} or to supply a new index pass a string or an array in preferred order.

\subparagraph*{last\+Modified}

Enable or disable {\ttfamily Last-\/\+Modified} header, defaults to true. Uses the file system\textquotesingle{}s last modified value.

\subparagraph*{max\+Age}

Provide a max-\/age in milliseconds for http caching, defaults to 0. This can also be a string accepted by the \href{https://www.npmjs.org/package/ms#readme}{\tt ms} module.

\subparagraph*{root}

Serve files relative to {\ttfamily path}.

\subparagraph*{start}

Byte offset at which the stream starts, defaults to 0. The start is inclusive, meaning {\ttfamily start\+: 2} will include the 3rd byte in the stream.

\paragraph*{Events}

The {\ttfamily Send\+Stream} is an event emitter and will emit the following events\+:


\begin{DoxyItemize}
\item {\ttfamily error} an error occurred {\ttfamily (err)}
\item {\ttfamily directory} a directory was requested {\ttfamily (res, path)}
\item {\ttfamily file} a file was requested {\ttfamily (path, stat)}
\item {\ttfamily headers} the headers are about to be set on a file {\ttfamily (res, path, stat)}
\item {\ttfamily stream} file streaming has started {\ttfamily (stream)}
\item {\ttfamily end} streaming has completed
\end{DoxyItemize}

\paragraph*{.pipe}

The {\ttfamily pipe} method is used to pipe the response into the Node.\+js H\+T\+TP response object, typically {\ttfamily send(req, path, options).pipe(res)}.

\subsubsection*{.mime}

The {\ttfamily mime} export is the global instance of of the \href{https://www.npmjs.com/package/mime}{\tt {\ttfamily mime} npm module}.

This is used to configure the M\+I\+ME types that are associated with file extensions as well as other options for how to resolve the M\+I\+ME type of a file (like the default type to use for an unknown file extension).

\subsection*{Error-\/handling}

By default when no {\ttfamily error} listeners are present an automatic response will be made, otherwise you have full control over the response, aka you may show a 5xx page etc.

\subsection*{Caching}

It does {\itshape not} perform internal caching, you should use a reverse proxy cache such as Varnish for this, or those fancy things called C\+D\+Ns. If your application is small enough that it would benefit from single-\/node memory caching, it\textquotesingle{}s small enough that it does not need caching at all ;).

\subsection*{Debugging}

To enable {\ttfamily debug()} instrumentation output export {\bfseries D\+E\+B\+UG}\+:


\begin{DoxyCode}
$ DEBUG=send node app
\end{DoxyCode}


\subsection*{Running tests}


\begin{DoxyCode}
$ npm install
$ npm test
\end{DoxyCode}


\subsection*{Examples}

\subsubsection*{Small example}


\begin{DoxyCode}
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

var server = http.createServer(function onRequest (req, res) \{
  send(req, parseUrl(req).pathname).pipe(res)
\})

server.listen(3000)
\end{DoxyCode}


\subsubsection*{Custom file types}


\begin{DoxyCode}
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

// Default unknown types to text/plain
send.mime.default\_type = 'text/plain'

// Add a custom type
send.mime.define(\{
  'application/x-my-type': ['x-mt', 'x-mtt']
\})

var server = http.createServer(function onRequest (req, res) \{
  send(req, parseUrl(req).pathname).pipe(res)
\})

server.listen(3000)
\end{DoxyCode}


\subsubsection*{Custom directory index view}

This is a example of serving up a structure of directories with a custom function to render a listing of a directory.


\begin{DoxyCode}
var http = require('http')
var fs = require('fs')
var parseUrl = require('parseurl')
var send = require('send')

// Transfer arbitrary files from within /www/example.com/public/*
// with a custom handler for directory listing
var server = http.createServer(function onRequest (req, res) \{
  send(req, parseUrl(req).pathname, \{index: false, root: '/www/example.com/public'\})
  .once('directory', directory)
  .pipe(res)
\})

server.listen(3000)

// Custom directory handler
function directory (res, path) \{
  var stream = this

  // redirect to trailing slash for consistent url
  if (!stream.hasTrailingSlash()) \{
    return stream.redirect(path)
  \}

  // get directory list
  fs.readdir(path, function onReaddir (err, list) \{
    if (err) return stream.error(err)

    // render an index for the directory
    res.setHeader('Content-Type', 'text/plain; charset=UTF-8')
    res.end(list.join('\(\backslash\)n') + '\(\backslash\)n')
  \})
\}
\end{DoxyCode}


\subsubsection*{Serving from a root directory with custom error-\/handling}


\begin{DoxyCode}
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

var server = http.createServer(function onRequest (req, res) \{
  // your custom error-handling logic:
  function error (err) \{
    res.statusCode = err.status || 500
    res.end(err.message)
  \}

  // your custom headers
  function headers (res, path, stat) \{
    // serve all files for download
    res.setHeader('Content-Disposition', 'attachment')
  \}

  // your custom directory handling logic:
  function redirect () \{
    res.statusCode = 301
    res.setHeader('Location', req.url + '/')
    res.end('Redirecting to ' + req.url + '/')
  \}

  // transfer arbitrary files from within
  // /www/example.com/public/*
  send(req, parseUrl(req).pathname, \{root: '/www/example.com/public'\})
  .on('error', error)
  .on('directory', redirect)
  .on('headers', headers)
  .pipe(res)
\})

server.listen(3000)
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 