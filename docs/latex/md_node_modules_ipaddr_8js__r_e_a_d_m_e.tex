ipaddr.\+js is a small (1.\+9K minified and gzipped) library for manipulating IP addresses in Java\+Script environments. It runs on both Common\+JS runtimes (e.\+g. \href{http://nodejs.org}{\tt nodejs}) and in a web browser.

ipaddr.\+js allows you to verify and parse string representation of an IP address, match it against a C\+I\+DR range or range list, determine if it falls into some reserved ranges (examples include loopback and private ranges), and convert between I\+Pv4 and I\+Pv4-\/mapped I\+Pv6 addresses.

\subsection*{Installation}

{\ttfamily npm install ipaddr.\+js}

or

{\ttfamily bower install ipaddr.\+js}

\subsection*{A\+PI}

ipaddr.\+js defines one object in the global scope\+: {\ttfamily ipaddr}. In Common\+JS, it is exported from the module\+:


\begin{DoxyCode}
var ipaddr = require('ipaddr.js');
\end{DoxyCode}


The A\+PI consists of several global methods and two classes\+: ipaddr.\+I\+Pv6 and ipaddr.\+I\+Pv4.

\subsubsection*{Global methods}

There are three global methods defined\+: {\ttfamily ipaddr.\+is\+Valid}, {\ttfamily ipaddr.\+parse} and {\ttfamily ipaddr.\+process}. All of them receive a string as a single parameter.

The {\ttfamily ipaddr.\+is\+Valid} method returns {\ttfamily true} if the address is a valid I\+Pv4 or I\+Pv6 address, and {\ttfamily false} otherwise. It does not throw any exceptions.

The {\ttfamily ipaddr.\+parse} method returns an object representing the IP address, or throws an {\ttfamily Error} if the passed string is not a valid representation of an IP address.

The {\ttfamily ipaddr.\+process} method works just like the {\ttfamily ipaddr.\+parse} one, but it automatically converts I\+Pv4-\/mapped I\+Pv6 addresses to their I\+Pv4 counterparts before returning. It is useful when you have a Node.\+js instance listening on an I\+Pv6 socket, and the {\ttfamily net.\+ivp6.\+bindv6only} sysctl parameter (or its equivalent on non-\/\+Linux OS) is set to 0. In this case, you can accept I\+Pv4 connections on your I\+Pv6-\/only socket, but the remote address will be mangled. Use {\ttfamily ipaddr.\+process} method to automatically demangle it.

\subsubsection*{Object representation}

Parsing methods return an object which descends from {\ttfamily ipaddr.\+I\+Pv6} or {\ttfamily ipaddr.\+I\+Pv4}. These objects share some properties, but most of them differ.

\paragraph*{Shared properties}

One can determine the type of address by calling {\ttfamily addr.\+kind()}. It will return either {\ttfamily \char`\"{}ipv6\char`\"{}} or {\ttfamily \char`\"{}ipv4\char`\"{}}.

An address can be converted back to its string representation with {\ttfamily addr.\+to\+String()}. Note that this method\+:
\begin{DoxyItemize}
\item does not return the original string used to create the object (in fact, there is no way of getting that string)
\item returns a compact representation (when it is applicable)
\end{DoxyItemize}

A {\ttfamily match(range, bits)} method can be used to check if the address falls into a certain C\+I\+DR range. Note that an address can be (obviously) matched only against an address of the same type.

For example\+:


\begin{DoxyCode}
var addr = ipaddr.parse("2001:db8:1234::1");
var range = ipaddr.parse("2001:db8::");

addr.match(range, 32); // => true
\end{DoxyCode}


Alternatively, {\ttfamily match} can also be called as {\ttfamily match(\mbox{[}range, bits\mbox{]})}. In this way, it can be used together with the {\ttfamily parse\+C\+I\+D\+R(string)} method, which parses an IP address together with a C\+I\+DR range.

For example\+:


\begin{DoxyCode}
var addr = ipaddr.parse("2001:db8:1234::1");

addr.match(ipaddr.parseCIDR("2001:db8::/32")); // => true
\end{DoxyCode}


A {\ttfamily range()} method returns one of predefined names for several special ranges defined by IP protocols. The exact names (and their respective C\+I\+DR ranges) can be looked up in the source\+: \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L186}{\tt I\+Pv6 ranges} and \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L71}{\tt I\+Pv4 ranges}. Some common ones include {\ttfamily \char`\"{}unicast\char`\"{}} (the default one) and {\ttfamily \char`\"{}reserved\char`\"{}}.

You can match against your own range list by using {\ttfamily ipaddr.\+subnet\+Match(address, range\+List, default\+Name)} method. It can work with a mix of I\+Pv6 or I\+Pv4 addresses, and accepts a name-\/to-\/subnet map as the range list. For example\+:


\begin{DoxyCode}
var rangeList = \{
  documentationOnly: [ ipaddr.parse('2001:db8::'), 32 ],
  tunnelProviders: [
    [ ipaddr.parse('2001:470::'), 32 ], // he.net
    [ ipaddr.parse('2001:5c0::'), 32 ]  // freenet6
  ]
\};
ipaddr.subnetMatch(ipaddr.parse('2001:470:8:66::1'), rangeList, 'unknown'); // => "tunnelProviders"
\end{DoxyCode}


The addresses can be converted to their byte representation with {\ttfamily to\+Byte\+Array()}. (Actually, Java\+Script mostly does not know about byte buffers. They are emulated with arrays of numbers, each in range of 0..255.)


\begin{DoxyCode}
var bytes = ipaddr.parse('2a00:1450:8007::68').toByteArray(); // ipv6.google.com
bytes // => [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, <zeroes...>, 0x00, 0x68 ]
\end{DoxyCode}


The {\ttfamily ipaddr.\+I\+Pv4} and {\ttfamily ipaddr.\+I\+Pv6} objects have some methods defined, too. All of them have the same interface for both protocols, and are similar to global methods.

{\ttfamily ipaddr.\+I\+Pv\+X.\+is\+Valid(string)} can be used to check if the string is a valid address for particular protocol, and {\ttfamily ipaddr.\+I\+Pv\+X.\+parse(string)} is the error-\/throwing parser.

{\ttfamily ipaddr.\+I\+Pv\+X.\+is\+Valid(string)} uses the same format for parsing as the P\+O\+S\+IX {\ttfamily inet\+\_\+ntoa} function, which accepts unusual formats like {\ttfamily 0xc0.\+168.\+1.\+1} or {\ttfamily 0x10000000}. The function {\ttfamily ipaddr.\+I\+Pv4.\+is\+Valid\+Four\+Part\+Decimal(string)} validates the I\+Pv4 address and also ensures that it is written in four-\/part decimal format.

\paragraph*{I\+Pv6 properties}

Sometimes you will want to convert I\+Pv6 not to a compact string representation (with the {\ttfamily \+:\+:} substitution); the {\ttfamily to\+Normalized\+String()} method will return an address where all zeroes are explicit.

For example\+:


\begin{DoxyCode}
var addr = ipaddr.parse("2001:0db8::0001");
addr.toString(); // => "2001:db8::1"
addr.toNormalizedString(); // => "2001:db8:0:0:0:0:0:1"
\end{DoxyCode}


The {\ttfamily is\+I\+Pv4\+Mapped\+Address()} method will return {\ttfamily true} if this address is an I\+Pv4-\/mapped one, and {\ttfamily to\+I\+Pv4\+Address()} will return an I\+Pv4 object address.

To access the underlying binary representation of the address, use {\ttfamily addr.\+parts}.


\begin{DoxyCode}
var addr = ipaddr.parse("2001:db8:10::1234:DEAD");
addr.parts // => [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]
\end{DoxyCode}


A I\+Pv6 zone index can be accessed via {\ttfamily addr.\+zone\+Id}\+:


\begin{DoxyCode}
var addr = ipaddr.parse("2001:db8::%eth0");
addr.zoneId // => 'eth0'
\end{DoxyCode}


\paragraph*{I\+Pv4 properties}

{\ttfamily to\+I\+Pv4\+Mapped\+Address()} will return a corresponding I\+Pv4-\/mapped I\+Pv6 address.

To access the underlying representation of the address, use {\ttfamily addr.\+octets}.


\begin{DoxyCode}
var addr = ipaddr.parse("192.168.1.1");
addr.octets // => [192, 168, 1, 1]
\end{DoxyCode}


{\ttfamily prefix\+Length\+From\+Subnet\+Mask()} will return a C\+I\+DR prefix length for a valid I\+Pv4 netmask or false if the netmask is not valid.


\begin{DoxyCode}
ipaddr.IPv4.parse('255.255.255.240').prefixLengthFromSubnetMask() == 28
ipaddr.IPv4.parse('255.192.164.0').prefixLengthFromSubnetMask()  == null
\end{DoxyCode}


{\ttfamily subnet\+Mask\+From\+Prefix\+Length()} will return an I\+Pv4 netmask for a valid C\+I\+DR prefix length.


\begin{DoxyCode}
ipaddr.IPv4.subnetMaskFromPrefixLength(24) == "255.255.255.0"
ipaddr.IPv4.subnetMaskFromPrefixLength(29) == "255.255.255.248"
\end{DoxyCode}


{\ttfamily broadcast\+Address\+From\+C\+I\+D\+R()} will return the broadcast address for a given I\+Pv4 interface and netmask in C\+I\+DR notation. 
\begin{DoxyCode}
ipaddr.IPv4.broadcastAddressFromCIDR("172.0.0.1/24") == "172.0.0.255"
\end{DoxyCode}
 {\ttfamily network\+Address\+From\+C\+I\+D\+R()} will return the network address for a given I\+Pv4 interface and netmask in C\+I\+DR notation. 
\begin{DoxyCode}
ipaddr.IPv4.networkAddressFromCIDR("172.0.0.1/24") == "172.0.0.0"
\end{DoxyCode}


\paragraph*{Conversion}

I\+Pv4 and I\+Pv6 can be converted bidirectionally to and from network byte order (M\+SB) byte arrays.

The {\ttfamily from\+Byte\+Array()} method will take an array and create an appropriate I\+Pv4 or I\+Pv6 object if the input satisfies the requirements. For I\+Pv4 it has to be an array of four 8-\/bit values, while for I\+Pv6 it has to be an array of sixteen 8-\/bit values.

For example\+: 
\begin{DoxyCode}
var addr = ipaddr.fromByteArray([0x7f, 0, 0, 1]);
addr.toString(); // => "127.0.0.1"
\end{DoxyCode}


or


\begin{DoxyCode}
var addr = ipaddr.fromByteArray([0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
addr.toString(); // => "2001:db8::1"
\end{DoxyCode}


Both objects also offer a {\ttfamily to\+Byte\+Array()} method, which returns an array in network byte order (M\+SB).

For example\+: 
\begin{DoxyCode}
var addr = ipaddr.parse("127.0.0.1");
addr.toByteArray(); // => [0x7f, 0, 0, 1]
\end{DoxyCode}


or


\begin{DoxyCode}
var addr = ipaddr.parse("2001:db8::1");
addr.toByteArray(); // => [0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
\end{DoxyCode}
 