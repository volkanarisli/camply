\href{https://travis-ci.org/ternjs/acorn}{\tt } \href{https://www.npmjs.com/package/acorn}{\tt } ~\newline
\href{https://marijnhaverbeke.nl/fund/}{\tt Author funding status\+: }

A tiny, fast Java\+Script parser, written completely in Java\+Script.

\subsection*{Community}

Acorn is open source software released under an \href{https://github.com/ternjs/acorn/blob/master/LICENSE}{\tt M\+IT license}.

You are welcome to \href{https://github.com/ternjs/acorn/issues}{\tt report bugs} or create pull requests on \href{https://github.com/ternjs/acorn}{\tt github}. For questions and discussion, please use the \href{https://discuss.ternjs.net}{\tt Tern discussion forum}.

\subsection*{Installation}

The easiest way to install acorn is with \href{https://www.npmjs.com/}{\tt {\ttfamily npm}}.


\begin{DoxyCode}
npm install acorn
\end{DoxyCode}


Alternately, download the source.


\begin{DoxyCode}
git clone https://github.com/ternjs/acorn.git
\end{DoxyCode}


\subsection*{Components}

When run in a Common\+JS (node.\+js) or A\+MD environment, exported values appear in the interfaces exposed by the individual files, as usual. When loaded in the browser (Acorn works in any J\+S-\/enabled browser more recent than I\+E5) without any kind of module management, a single global object {\ttfamily acorn} will be defined, and all the exported properties will be added to that.

\subsubsection*{Main parser}

This is implemented in {\ttfamily dist/acorn.\+js}, and is what you get when you {\ttfamily require(\char`\"{}acorn\char`\"{})} in node.\+js.

{\bfseries parse}{\ttfamily (input, options)} is used to parse a Java\+Script program. The {\ttfamily input} parameter is a string, {\ttfamily options} can be undefined or an object setting some of the options listed below. The return value will be an abstract syntax tree object as specified by the \href{https://github.com/estree/estree}{\tt E\+S\+Tree spec}.

When encountering a syntax error, the parser will raise a {\ttfamily Syntax\+Error} object with a meaningful message. The error object will have a {\ttfamily pos} property that indicates the character offset at which the error occurred, and a {\ttfamily loc} object that contains a {\ttfamily \{line, column\}} object referring to that same position.


\begin{DoxyItemize}
\item {\bfseries ecma\+Version}\+: Indicates the E\+C\+M\+A\+Script version to parse. Must be either 3, 5, or 6. This influences support for strict mode, the set of reserved words, and support for new syntax features. Default is 5.
\item {\bfseries source\+Type}\+: Indicate the mode the code should be parsed in. Can be either {\ttfamily \char`\"{}script\char`\"{}} or {\ttfamily \char`\"{}module\char`\"{}}.
\item {\bfseries on\+Inserted\+Semicolon}\+: If given a callback, that callback will be called whenever a missing semicolon is inserted by the parser. The callback will be given the character offset of the point where the semicolon is inserted as argument, and if {\ttfamily locations} is on, also a {\ttfamily \{line, column\}} object representing this position.
\item {\bfseries on\+Trailing\+Comma}\+: Like {\ttfamily on\+Inserted\+Semicolon}, but for trailing commas.
\item {\bfseries allow\+Reserved}\+: If {\ttfamily false}, using a reserved word will generate an error. Defaults to {\ttfamily true} for {\ttfamily ecma\+Version} 3, {\ttfamily false} for higher versions. When given the value {\ttfamily \char`\"{}never\char`\"{}}, reserved words and keywords can also not be used as property names (as in Internet Explorer\textquotesingle{}s old parser).
\item {\bfseries allow\+Return\+Outside\+Function}\+: By default, a return statement at the top level raises an error. Set this to {\ttfamily true} to accept such code.
\item {\bfseries allow\+Import\+Export\+Everywhere}\+: By default, {\ttfamily import} and {\ttfamily export} declarations can only appear at a program\textquotesingle{}s top level. Setting this option to {\ttfamily true} allows them anywhere where a statement is allowed.
\item {\bfseries allow\+Hash\+Bang}\+: When this is enabled (off by default), if the code starts with the characters {\ttfamily \#!} (as in a shellscript), the first line will be treated as a comment.
\item {\bfseries locations}\+: When {\ttfamily true}, each node has a {\ttfamily loc} object attached with {\ttfamily start} and {\ttfamily end} subobjects, each of which contains the one-\/based line and zero-\/based column numbers in {\ttfamily \{line, column\}} form. Default is {\ttfamily false}.
\item {\bfseries on\+Token}\+: If a function is passed for this option, each found token will be passed in same format as tokens returned from {\ttfamily tokenizer().get\+Token()}.

If array is passed, each found token is pushed to it.

Note that you are not allowed to call the parser from the callback—that will corrupt its internal state.
\item {\bfseries on\+Comment}\+: If a function is passed for this option, whenever a comment is encountered the function will be called with the following parameters\+:
\begin{DoxyItemize}
\item {\ttfamily block}\+: {\ttfamily true} if the comment is a block comment, false if it is a line comment.
\item {\ttfamily text}\+: The content of the comment.
\item {\ttfamily start}\+: Character offset of the start of the comment.
\item {\ttfamily end}\+: Character offset of the end of the comment.
\end{DoxyItemize}

When the {\ttfamily locations} options is on, the {\ttfamily \{line, column\}} locations of the comment’s start and end are passed as two additional parameters.

If array is passed for this option, each found comment is pushed to it as object in Esprima format\+:
\end{DoxyItemize}


\begin{DoxyCode}
\{
  "type": "Line" | "Block",
  "value": "comment text",
  "start": Number,
  "end": Number,
  // If `locations` option is on:
  "loc": \{
    "start": \{line: Number, column: Number\}
    "end": \{line: Number, column: Number\}
  \},
  // If `ranges` option is on:
  "range": [Number, Number]
\}
\end{DoxyCode}


Note that you are not allowed to call the parser from the callback—that will corrupt its internal state.


\begin{DoxyItemize}
\item {\bfseries ranges}\+: Nodes have their start and end characters offsets recorded in {\ttfamily start} and {\ttfamily end} properties (directly on the node, rather than the {\ttfamily loc} object, which holds line/column data. To also add a \href{https://bugzilla.mozilla.org/show_bug.cgi?id=745678}{\tt semi-\/standardized} {\ttfamily range} property holding a {\ttfamily \mbox{[}start, end\mbox{]}} array with the same numbers, set the {\ttfamily ranges} option to {\ttfamily true}.
\item {\bfseries program}\+: It is possible to parse multiple files into a single A\+ST by passing the tree produced by parsing the first file as the {\ttfamily program} option in subsequent parses. This will add the toplevel forms of the parsed file to the \char`\"{}\+Program\char`\"{} (top) node of an existing parse tree.
\item {\bfseries source\+File}\+: When the {\ttfamily locations} option is {\ttfamily true}, you can pass this option to add a {\ttfamily source} attribute in every node’s {\ttfamily loc} object. Note that the contents of this option are not examined or processed in any way; you are free to use whatever format you choose.
\item {\bfseries direct\+Source\+File}\+: Like {\ttfamily source\+File}, but a {\ttfamily source\+File} property will be added directly to the nodes, rather than the {\ttfamily loc} object.
\item {\bfseries preserve\+Parens}\+: If this option is {\ttfamily true}, parenthesized expressions are represented by (non-\/standard) {\ttfamily Parenthesized\+Expression} nodes that have a single {\ttfamily expression} property containing the expression inside parentheses.
\end{DoxyItemize}

{\bfseries parse\+Expression\+At}{\ttfamily (input, offset, options)} will parse a single expression in a string, and return its A\+ST. It will not complain if there is more of the string left after the expression.

{\bfseries get\+Line\+Info}{\ttfamily (input, offset)} can be used to get a {\ttfamily \{line, column\}} object for a given program string and character offset.

{\bfseries tokenizer}{\ttfamily (input, options)} returns an object with a {\ttfamily get\+Token} method that can be called repeatedly to get the next token, a {\ttfamily \{start, end, type, value\}} object (with added {\ttfamily loc} property when the {\ttfamily locations} option is enabled and {\ttfamily range} property when the {\ttfamily ranges} option is enabled). When the token\textquotesingle{}s type is {\ttfamily tok\+Types.\+eof}, you should stop calling the method, since it will keep returning that same token forever.

In E\+S6 environment, returned result can be used as any other protocol-\/compliant iterable\+:


\begin{DoxyCode}
for (let token of acorn.tokenizer(str)) \{
  // iterate over the tokens
\}

// transform code to array of tokens:
var tokens = [...acorn.tokenizer(str)];
\end{DoxyCode}


{\bfseries tok\+Types} holds an object mapping names to the token type objects that end up in the {\ttfamily type} properties of tokens.

\paragraph*{Note on using with \href{https://github.com/estools/escodegen}{\tt Escodegen}}

Escodegen supports generating comments from A\+ST, attached in Esprima-\/specific format. In order to simulate same format in Acorn, consider following example\+:


\begin{DoxyCode}
var comments = [], tokens = [];

var ast = acorn.parse('var x = 42; // answer', \{
  // collect ranges for each node
  ranges: true,
  // collect comments in Esprima's format
  onComment: comments,
  // collect token ranges
  onToken: tokens
\});

// attach comments using collected information
escodegen.attachComments(ast, comments, tokens);

// generate code
console.log(escodegen.generate(ast, \{comment: true\}));
// > 'var x = 42;    // answer'
\end{DoxyCode}


\subsubsection*{dist/acorn\+\_\+loose.\+js}

This file implements an error-\/tolerant parser. It exposes a single function. The loose parser is accessible in node.\+js via {\ttfamily require(\char`\"{}acorn/dist/acorn\+\_\+loose\char`\"{})}.

{\bfseries parse\+\_\+dammit}{\ttfamily (input, options)} takes the same arguments and returns the same syntax tree as the {\ttfamily parse} function in {\ttfamily acorn.\+js}, but never raises an error, and will do its best to parse syntactically invalid code in as meaningful a way as it can. It\textquotesingle{}ll insert identifier nodes with name {\ttfamily \char`\"{}✖\char`\"{}} as placeholders in places where it can\textquotesingle{}t make sense of the input. Depends on {\ttfamily acorn.\+js}, because it uses the same tokenizer.

\subsubsection*{dist/walk.\+js}

Implements an abstract syntax tree walker. Will store its interface in {\ttfamily acorn.\+walk} when loaded without a module system.

{\bfseries simple}{\ttfamily (node, visitors, base, state)} does a \textquotesingle{}simple\textquotesingle{} walk over a tree. {\ttfamily node} should be the A\+ST node to walk, and {\ttfamily visitors} an object with properties whose names correspond to node types in the \href{https://github.com/estree/estree}{\tt E\+S\+Tree spec}. The properties should contain functions that will be called with the node object and, if applicable the state at that point. The last two arguments are optional. {\ttfamily base} is a walker algorithm, and {\ttfamily state} is a start state. The default walker will simply visit all statements and expressions and not produce a meaningful state. (An example of a use of state is to track scope at each point in the tree.)

{\bfseries ancestor}{\ttfamily (node, visitors, base, state)} does a \textquotesingle{}simple\textquotesingle{} walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to callbacks in the {\ttfamily state} parameter.

{\bfseries recursive}{\ttfamily (node, state, functions, base)} does a \textquotesingle{}recursive\textquotesingle{} walk, where the walker functions are responsible for continuing the walk on the child nodes of their target node. {\ttfamily state} is the start state, and {\ttfamily functions} should contain an object that maps node types to walker functions. Such functions are called with {\ttfamily (node, state, c)} arguments, and can cause the walk to continue on a sub-\/node by calling the {\ttfamily c} argument on it with {\ttfamily (node, state)} arguments. The optional {\ttfamily base} argument provides the fallback walker functions for node types that aren\textquotesingle{}t handled in the {\ttfamily functions} object. If not given, the default walkers will be used.

{\bfseries make}{\ttfamily (functions, base)} builds a new walker object by using the walker functions in {\ttfamily functions} and filling in the missing ones by taking defaults from {\ttfamily base}.

{\bfseries find\+Node\+At}{\ttfamily (node, start, end, test, base, state)} tries to locate a node in a tree at the given start and/or end offsets, which satisfies the predicate {\ttfamily test}. {\ttfamily start} and {\ttfamily end} can be either {\ttfamily null} (as wildcard) or a number. {\ttfamily test} may be a string (indicating a node type) or a function that takes {\ttfamily (node\+Type, node)} arguments and returns a boolean indicating whether this node is interesting. {\ttfamily base} and {\ttfamily state} are optional, and can be used to specify a custom walker. Nodes are tested from inner to outer, so if two nodes match the boundaries, the inner one will be preferred.

{\bfseries find\+Node\+Around}{\ttfamily (node, pos, test, base, state)} is a lot like {\ttfamily find\+Node\+At}, but will match any node that exists \textquotesingle{}around\textquotesingle{} (spanning) the given position.

{\bfseries find\+Node\+After}{\ttfamily (node, pos, test, base, state)} is similar to {\ttfamily find\+Node\+Around}, but will match all nodes {\itshape after} the given position (testing outer nodes before inner nodes).

\subsection*{Command line interface}

The {\ttfamily bin/acorn} utility can be used to parse a file from the command line. It accepts as arguments its input file and the following options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/-\/ecma3$\vert$-\/-\/ecma5$\vert$-\/-\/ecma6}\+: Sets the E\+C\+M\+A\+Script version to parse. Default is version 5.
\item {\ttfamily -\/-\/module}\+: Sets the parsing mode to {\ttfamily \char`\"{}module\char`\"{}}. Is set to {\ttfamily \char`\"{}script\char`\"{}} otherwise.
\item {\ttfamily -\/-\/locations}\+: Attaches a \char`\"{}loc\char`\"{} object to each node with \char`\"{}start\char`\"{} and \char`\"{}end\char`\"{} subobjects, each of which contains the one-\/based line and zero-\/based column numbers in {\ttfamily \{line, column\}} form.
\item {\ttfamily -\/-\/allow-\/hash-\/bang}\+: If the code starts with the characters \#! (as in a shellscript), the first line will be treated as a comment.
\item {\ttfamily -\/-\/compact}\+: No whitespace is used in the A\+ST output.
\item {\ttfamily -\/-\/silent}\+: Do not output the A\+ST, just return the exit status.
\item {\ttfamily -\/-\/help}\+: Print the usage information and quit.
\end{DoxyItemize}

The utility spits out the syntax tree as J\+S\+ON data.

\subsection*{Build system}

Acorn is written in E\+C\+M\+A\+Script 6, as a set of small modules, in the project\textquotesingle{}s {\ttfamily src} directory, and compiled down to bigger E\+C\+M\+A\+Script 3 files in {\ttfamily dist} using \href{http://browserify.org}{\tt Browserify} and \href{http://babeljs.io/}{\tt Babel}. If you are already using Babel, you can consider including the modules directly.

The command-\/line test runner ({\ttfamily npm test}) uses the E\+S6 modules. The browser-\/based test page ({\ttfamily test/index.\+html}) uses the compiled modules. The {\ttfamily bin/build-\/acorn.\+js} script builds the latter from the former.

If you are working on Acorn, you\textquotesingle{}ll probably want to try the code out directly, without an intermediate build step. In your scripts, you can register the Babel require shim like this\+: \begin{DoxyVerb}require("babel-core/register")
\end{DoxyVerb}


That will allow you to directly {\ttfamily require} the E\+S6 modules.

\subsection*{Plugins}

Acorn is designed support allow plugins which, within reasonable bounds, redefine the way the parser works. Plugins can add new token types and new tokenizer contexts (if necessary), and extend methods in the parser object. This is not a clean, elegant A\+P\+I—using it requires an understanding of Acorn\textquotesingle{}s internals, and plugins are likely to break whenever those internals are significantly changed. But still, it is {\itshape possible}, in this way, to create parsers for Java\+Script dialects without forking all of Acorn. And in principle it is even possible to combine such plugins, so that if you have, for example, a plugin for parsing types and a plugin for parsing J\+S\+X-\/style X\+ML literals, you could load them both and parse code with both J\+SX tags and types.

A plugin should register itself by adding a property to {\ttfamily acorn.\+plugins}, which holds a function. Calling {\ttfamily acorn.\+parse}, a {\ttfamily plugins} option can be passed, holding an object mapping plugin names to configuration values (or just {\ttfamily true} for plugins that don\textquotesingle{}t take options). After the parser object has been created, the initialization functions for the chosen plugins are called with {\ttfamily (parser, config\+Value)} arguments. They are expected to use the {\ttfamily parser.\+extend} method to extend parser methods. For example, the {\ttfamily read\+Token} method could be extended like this\+:


\begin{DoxyCode}
parser.extend("readToken", function(nextMethod) \{
  return function(code) \{
    console.log("Reading a token!")
    return nextMethod.call(this, code)
  \}
\})
\end{DoxyCode}


The {\ttfamily next\+Method} argument passed to {\ttfamily extend}\textquotesingle{}s second argument is the previous value of this method, and should usually be called through to whenever the extended method does not handle the call itself.

Similarly, the loose parser allows plugins to register themselves via {\ttfamily acorn.\+plugins\+Loose}. The extension mechanism is the same as for the normal parser\+:


\begin{DoxyCode}
looseParser.extend("readToken", function(nextMethod) \{
  return function() \{
    console.log("Reading a token in the loose parser!")
    return nextMethod.call(this)
  \}
\})
\end{DoxyCode}


There is a proof-\/of-\/concept J\+SX plugin in the \href{https://github.com/RReverser/acorn-jsx}{\tt {\ttfamily acorn-\/jsx}} project. 