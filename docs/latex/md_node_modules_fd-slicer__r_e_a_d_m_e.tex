\href{https://travis-ci.org/andrewrk/node-fd-slicer}{\tt }

Safe {\ttfamily fs.\+Read\+Stream} and {\ttfamily fs.\+Write\+Stream} using the same fd.

Let\textquotesingle{}s say that you want to perform a parallel upload of a file to a remote server. To do this, we want to create multiple read streams. The first thing you might think of is to use the {\ttfamily \{start\+: 0, end\+: 0\}} A\+PI of {\ttfamily fs.\+create\+Read\+Stream}. This gives you two choices\+:

0. Use the same file descriptor for all {\ttfamily fs.\+Read\+Stream} objects. 0. Open the file multiple times, resulting in a separate file descriptor for each read stream.

Neither of these are acceptable options. The first one is a severe bug, because the A\+PI docs for {\ttfamily fs.\+write} state\+:

\begin{quote}
Note that it is unsafe to use {\ttfamily fs.\+write} multiple times on the same file without waiting for the callback. For this scenario, {\ttfamily fs.\+create\+Write\+Stream} is strongly recommended. \end{quote}


{\ttfamily fs.\+create\+Write\+Stream} will solve the problem if you only create one of them for the file descriptor, but it will exhibit this unsafety if you create multiple write streams per file descriptor.

The second option suffers from a race condition. For each additional time the file is opened after the first, it is possible that the file is modified. So in our parallel uploading example, we might upload a corrupt file that never existed on the client\textquotesingle{}s computer.

This module solves this problem by providing {\ttfamily create\+Read\+Stream} and {\ttfamily create\+Write\+Stream} that operate on a shared file descriptor and provides the convenient stream A\+PI while still allowing slicing and dicing.

This module also gives you some additional power that the builtin {\ttfamily fs.\+create\+Write\+Stream} do not give you. These features are\+:


\begin{DoxyItemize}
\item Emitting a \textquotesingle{}progress\textquotesingle{} event on write.
\item Ability to set a maximum size and emit an error if this size is exceeded.
\item Ability to create an {\ttfamily Fd\+Slicer} instance from a {\ttfamily Buffer}. This enables you to provide A\+PI for handling files as well as buffers using the same A\+PI.
\end{DoxyItemize}

\subsection*{Usage}


\begin{DoxyCode}
var fdSlicer = require('fd-slicer');
var fs = require('fs');

fs.open("file.txt", 'r', function(err, fd) \{
  if (err) throw err;
  var slicer = fdSlicer.createFromFd(fd);
  var firstPart = slicer.createReadStream(\{start: 0, end: 100\});
  var secondPart = slicer.createReadStream(\{start: 100\});
  var firstOut = fs.createWriteStream("first.txt");
  var secondOut = fs.createWriteStream("second.txt");
  firstPart.pipe(firstOut);
  secondPart.pipe(secondOut);
\});
\end{DoxyCode}


You can also create from a buffer\+:


\begin{DoxyCode}
var fdSlicer = require('fd-slicer');
var slicer = FdSlicer.createFromBuffer(someBuffer);
var firstPart = slicer.createReadStream(\{start: 0, end: 100\});
var secondPart = slicer.createReadStream(\{start: 100\});
var firstOut = fs.createWriteStream("first.txt");
var secondOut = fs.createWriteStream("second.txt");
firstPart.pipe(firstOut);
secondPart.pipe(secondOut);
\end{DoxyCode}


\subsection*{A\+PI Documentation}

\subsubsection*{fd\+Slicer.\+create\+From\+Fd(fd, \mbox{[}options\mbox{]})}


\begin{DoxyCode}
var fdSlicer = require('fd-slicer');
fs.open("file.txt", 'r', function(err, fd) \{
  if (err) throw err;
  var slicer = fdSlicer.createFromFd(fd);
  // ...
\});
\end{DoxyCode}


Make sure {\ttfamily fd} is a properly initialized file descriptor. If you want to use {\ttfamily create\+Read\+Stream} make sure you open it for reading and if you want to use {\ttfamily create\+Write\+Stream} make sure you open it for writing.

{\ttfamily options} is an optional object which can contain\+:


\begin{DoxyItemize}
\item {\ttfamily auto\+Close} -\/ if set to {\ttfamily true}, the file descriptor will be automatically closed once the last stream that references it is closed. Defaults to {\ttfamily false}. {\ttfamily ref()} and {\ttfamily unref()} can be used to increase or decrease the reference count, respectively.
\end{DoxyItemize}

\subsubsection*{fd\+Slicer.\+create\+From\+Buffer(buffer, \mbox{[}options\mbox{]})}


\begin{DoxyCode}
var fdSlicer = require('fd-slicer');
var slicer = fdSlicer.createFromBuffer(someBuffer);
// ...
\end{DoxyCode}


{\ttfamily options} is an optional object which can contain\+:


\begin{DoxyItemize}
\item {\ttfamily max\+Chunk\+Size} -\/ A {\ttfamily Number} of bytes. see {\ttfamily create\+Read\+Stream()}. If falsey, defaults to unlimited.
\end{DoxyItemize}

\paragraph*{Properties}

\subparagraph*{fd}

The file descriptor passed in. {\ttfamily undefined} if created from a buffer.

\paragraph*{Methods}

\subparagraph*{create\+Read\+Stream(options)}

Available {\ttfamily options}\+:


\begin{DoxyItemize}
\item {\ttfamily start} -\/ Number. The offset into the file to start reading from. Defaults to 0.
\item {\ttfamily end} -\/ Number. Exclusive upper bound offset into the file to stop reading from.
\item {\ttfamily high\+Water\+Mark} -\/ Number. The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Defaults to 16 KB.
\item {\ttfamily encoding} -\/ String. If specified, then buffers will be decoded to strings using the specified encoding. Defaults to {\ttfamily null}.
\end{DoxyItemize}

The Readable\+Stream that this returns has these additional methods\+:


\begin{DoxyItemize}
\item {\ttfamily destroy(err)} -\/ stop streaming. {\ttfamily err} is optional and is the error that will be emitted in order to cause the streaming to stop. Defaults to {\ttfamily new Error(\char`\"{}stream destroyed\char`\"{})}.
\end{DoxyItemize}

If {\ttfamily max\+Chunk\+Size} was specified (see {\ttfamily create\+From\+Buffer()}), the read stream will provide chunks of at most that size. Normally, the read stream provides the entire range requested in a single chunk, but this can cause performance problems in some circumstances. See \href{https://github.com/thejoshwolfe/yauzl/issues/87}{\tt thejoshwolfe/yauzl\#87}.

\subparagraph*{create\+Write\+Stream(options)}

Available {\ttfamily options}\+:


\begin{DoxyItemize}
\item {\ttfamily start} -\/ Number. The offset into the file to start writing to. Defaults to 0.
\item {\ttfamily end} -\/ Number. Exclusive upper bound offset into the file. If this offset is reached, the write stream will emit an \textquotesingle{}error\textquotesingle{} event and stop functioning. In this situation, `err.\+code === \textquotesingle{}E\+T\+O\+O\+B\+IG'{\ttfamily . Defaults to}Infinity{\ttfamily . $\ast$}high\+Water\+Mark{\ttfamily -\/ Number. Buffer level when}write()\`{} starts returning false. Defaults to 16\+KB.
\item {\ttfamily decode\+Strings} -\/ Boolean. Whether or not to decode strings into Buffers before passing them to{\ttfamily \+\_\+write()}. Defaults to {\ttfamily true}.
\end{DoxyItemize}

The Writable\+Stream that this returns has these additional methods\+:


\begin{DoxyItemize}
\item {\ttfamily destroy()} -\/ stop streaming
\end{DoxyItemize}

And these additional properties\+:


\begin{DoxyItemize}
\item {\ttfamily bytes\+Written} -\/ number of bytes written to the stream
\end{DoxyItemize}

And these additional events\+:


\begin{DoxyItemize}
\item \textquotesingle{}progress\textquotesingle{} -\/ emitted when {\ttfamily bytes\+Written} changes.
\end{DoxyItemize}

\subparagraph*{read(buffer, offset, length, position, callback)}

Equivalent to {\ttfamily fs.\+read}, but with concurrency protection. {\ttfamily callback} must be defined.

\subparagraph*{write(buffer, offset, length, position, callback)}

Equivalent to {\ttfamily fs.\+write}, but with concurrency protection. {\ttfamily callback} must be defined.

\subparagraph*{ref()}

Increase the {\ttfamily auto\+Close} reference count by 1.

\subparagraph*{unref()}

Decrease the {\ttfamily auto\+Close} reference count by 1.

\paragraph*{Events}

\subparagraph*{\textquotesingle{}error\textquotesingle{}}

Emitted if {\ttfamily fs.\+close} returns an error when auto closing.

\subparagraph*{\textquotesingle{}close\textquotesingle{}}

Emitted when fd-\/slicer closes the file descriptor due to {\ttfamily auto\+Close}. Never emitted if created from a buffer. 