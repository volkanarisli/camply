\begin{quote}
Snapdragon utility for creating a new A\+ST node in custom code, such as plugins. \end{quote}


\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save snapdragon-node
\end{DoxyCode}


\subsection*{Usage}

With \href{https://github.com/jonschlinkert/snapdragon}{\tt snapdragon} v0.\+9.\+0 and higher you can use {\ttfamily this.\+node()} to create a new {\ttfamily Node}, whenever it makes sense.

\`{}\`{}`js var Node = require(\textquotesingle{}snapdragon-\/node'); var Snapdragon = require(\textquotesingle{}snapdragon\textquotesingle{}); var snapdragon = new Snapdragon();

// example usage inside a parser visitor function snapdragon.\+parser.\+set(\textquotesingle{}foo\textquotesingle{}, function() \{ // get the current \char`\"{}start\char`\"{} position var pos = this.\+position();

// returns the match if regex matches the substring // at the current position on {\ttfamily parser.\+input} var match = this.\+match(/foo/); if (match) \{ // call \char`\"{}pos\char`\"{} on the node, to set the start and end // positions, and return the node to push it onto the A\+ST // (snapdragon will push the node onto the correct // nodes array, based on the stack) return pos(new Node(\{type\+: \textquotesingle{}bar\textquotesingle{}, val\+: match\mbox{[}0\mbox{]}\})); \} \}); 
\begin{DoxyCode}
## API

### [Node](index.js#L22)

Create a new AST `Node` with the given `val` and `type`.

**Params**

* `val` **\{String|Object\}**: Pass a matched substring, or an object to merge onto the node.
* `type` **\{String\}**: The node type to use when `val` is a string.
* `returns` **\{Object\}**: node instance

**Example**

```js
var node = new Node('*', 'Star');
var node = new Node(\{type: 'star', val: '*'\});
\end{DoxyCode}


\subsubsection*{\href{index.js#L61}{\tt .is\+Node}}

Returns true if the given value is a node.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var node = new Node(\{type: 'foo'\});
console.log(Node.isNode(node)); //=> true
console.log(Node.isNode(\{\})); //=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L80}{\tt .define}}

Define a non-\/enumberable property on the node instance. Useful for adding properties that shouldn\textquotesingle{}t be extended or visible during debugging.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily name} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily val} $\ast$$\ast$\{any\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: returns the node instance
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node();
node.define('foo', 'something non-enumerable');
\end{DoxyCode}


\subsubsection*{\href{index.js#L100}{\tt .is\+Empty}}

Returns true if {\ttfamily node.\+val} is an empty string, or {\ttfamily node.\+nodes} does not contain any non-\/empty text nodes.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily fn} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: (optional) Filter function that is called on {\ttfamily node} and/or child nodes. {\ttfamily is\+Empty} will return false immediately when the filter function returns false on any nodes.
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{type: 'text'\});
node.isEmpty(); //=> true
node.val = 'foo';
node.isEmpty(); //=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L118}{\tt .push}}

Given node {\ttfamily foo} and node {\ttfamily bar}, push node {\ttfamily bar} onto {\ttfamily foo.\+nodes}, and set {\ttfamily foo} as {\ttfamily bar.\+parent}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Number\}$\ast$$\ast$\+: Returns the length of {\ttfamily node.\+nodes}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
foo.push(bar);
\end{DoxyCode}


\subsubsection*{\href{index.js#L140}{\tt .unshift}}

Given node {\ttfamily foo} and node {\ttfamily bar}, unshift node {\ttfamily bar} onto {\ttfamily foo.\+nodes}, and set {\ttfamily foo} as {\ttfamily bar.\+parent}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Number\}$\ast$$\ast$\+: Returns the length of {\ttfamily node.\+nodes}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
foo.unshift(bar);
\end{DoxyCode}


\subsubsection*{\href{index.js#L167}{\tt .pop}}

Pop a node from {\ttfamily node.\+nodes}.


\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Number\}$\ast$$\ast$\+: Returns the popped {\ttfamily node}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{type: 'foo'\});
node.push(new Node(\{type: 'a'\}));
node.push(new Node(\{type: 'b'\}));
node.push(new Node(\{type: 'c'\}));
node.push(new Node(\{type: 'd'\}));
console.log(node.nodes.length);
//=> 4
node.pop();
console.log(node.nodes.length);
//=> 3
\end{DoxyCode}


\subsubsection*{\href{index.js#L190}{\tt .shift}}

Shift a node from {\ttfamily node.\+nodes}.


\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the shifted {\ttfamily node}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{type: 'foo'\});
node.push(new Node(\{type: 'a'\}));
node.push(new Node(\{type: 'b'\}));
node.push(new Node(\{type: 'c'\}));
node.push(new Node(\{type: 'd'\}));
console.log(node.nodes.length);
//=> 4
node.shift();
console.log(node.nodes.length);
//=> 3
\end{DoxyCode}


\subsubsection*{\href{index.js#L205}{\tt .remove}}

Remove {\ttfamily node} from {\ttfamily node.\+nodes}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the removed node.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
node.remove(childNode);
\end{DoxyCode}


\subsubsection*{\href{index.js#L231}{\tt .find}}

Get the first child node from {\ttfamily node.\+nodes} that matches the given {\ttfamily type}. If {\ttfamily type} is a number, the child node at that index is returned.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns a child node or undefined.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var child = node.find(1); //<= index of the node to get
var child = node.find('foo'); //<= node.type of a child node
var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
var child = node.find(['foo', 'bar']); //<= array of node.type(s)
\end{DoxyCode}


\subsubsection*{\href{index.js#L249}{\tt .is\+Type}}

Return true if the node is the given {\ttfamily type}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{type: 'bar'\});
cosole.log(node.isType('foo'));          // false
cosole.log(node.isType(/^(foo|bar)$/));  // true
cosole.log(node.isType(['foo', 'bar'])); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L270}{\tt .has\+Type}}

Return true if the {\ttfamily node.\+nodes} has the given {\ttfamily type}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
foo.push(bar);

cosole.log(foo.hasType('qux'));          // false
cosole.log(foo.hasType(/^(qux|bar)$/));  // true
cosole.log(foo.hasType(['qux', 'bar'])); // true
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
foo.push(bar);
foo.push(baz);

console.log(bar.siblings.length) // 2
console.log(baz.siblings.length) // 2
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Number\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
var qux = new Node(\{type: 'qux'\});
foo.push(bar);
foo.push(baz);
foo.unshift(qux);

console.log(bar.index) // 1
console.log(baz.index) // 2
console.log(qux.index) // 0
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
foo.push(bar);
foo.push(baz);

console.log(baz.prev.type) // 'bar'
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
foo.push(bar);
foo.push(baz);

console.log(bar.siblings.length) // 2
console.log(baz.siblings.length) // 2
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The first node, or undefiend
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
var qux = new Node(\{type: 'qux'\});
foo.push(bar);
foo.push(baz);
foo.push(qux);

console.log(foo.first.type) // 'bar'
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The last node, or undefiend
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
var qux = new Node(\{type: 'qux'\});
foo.push(bar);
foo.push(baz);
foo.push(qux);

console.log(foo.last.type) // 'qux'
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The last node, or undefiend
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var foo = new Node(\{type: 'foo'\});
var bar = new Node(\{type: 'bar'\});
var baz = new Node(\{type: 'baz'\});
var qux = new Node(\{type: 'qux'\});
foo.push(bar);
foo.push(baz);
foo.push(qux);

console.log(foo.last.type) // 'qux'
\end{DoxyCode}


\subsection*{Release history}

Changelog entries are classified using the following labels from \href{https://github.com/olivierlacan/keep-a-changelog}{\tt keep-\/a-\/changelog}\+:


\begin{DoxyItemize}
\item {\ttfamily added}\+: for new features
\item {\ttfamily changed}\+: for changes in existing functionality
\item {\ttfamily deprecated}\+: for once-\/stable features removed in upcoming releases
\item {\ttfamily removed}\+: for deprecated features removed in this release
\item {\ttfamily fixed}\+: for any bug fixes
\end{DoxyItemize}

Custom labels used in this changelog\+:


\begin{DoxyItemize}
\item {\ttfamily dependencies}\+: bumps dependencies
\item {\ttfamily housekeeping}\+: code re-\/organization, minor edits, or other changes that don\textquotesingle{}t fit in one of the other categories.
\end{DoxyItemize}

\subsubsection*{\mbox{[}2.\+0.\+0\mbox{]} -\/ 2017-\/05-\/01}

{\bfseries Changed}


\begin{DoxyItemize}
\item {\ttfamily .unshift\+Node} was renamed to \href{#unshift}{\tt .unshift}
\item {\ttfamily .push\+Node} was renamed to \href{#push}{\tt .push}
\item {\ttfamily .get\+Node} was renamed to \href{#find}{\tt .find}
\end{DoxyItemize}

{\bfseries Added}


\begin{DoxyItemize}
\item \href{#isNode}{\tt .is\+Node}
\item \href{#isEmpty}{\tt .is\+Empty}
\item \href{#pop}{\tt .pop}
\item \href{#shift}{\tt .shift}
\item \href{#remove}{\tt .remove}
\end{DoxyItemize}

\subsubsection*{\mbox{[}0.\+1.\+0\mbox{]}}

First release.

\subsection*{About}

\subsubsection*{Related projects}


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/breakdance}{\tt breakdance}\+: Breakdance is a node.\+js library for converting H\+T\+ML to markdown. Highly pluggable, flexible and easy… \href{http://breakdance.io}{\tt more} $\vert$ \href{http://breakdance.io}{\tt homepage}
\item \href{https://www.npmjs.com/package/snapdragon-capture}{\tt snapdragon-\/capture}\+: Snapdragon plugin that adds a capture method to the parser instance. $\vert$ \href{https://github.com/jonschlinkert/snapdragon-capture}{\tt homepage}
\item \href{https://www.npmjs.com/package/snapdragon-cheerio}{\tt snapdragon-\/cheerio}\+: Snapdragon plugin for converting a cheerio A\+ST to a snapdragon A\+ST. $\vert$ \href{https://github.com/jonschlinkert/snapdragon-cheerio}{\tt homepage}
\item \href{https://www.npmjs.com/package/snapdragon-util}{\tt snapdragon-\/util}\+: Utilities for the snapdragon parser/compiler. $\vert$ \href{https://github.com/jonschlinkert/snapdragon-util}{\tt homepage}
\item \href{https://www.npmjs.com/package/snapdragon}{\tt snapdragon}\+: Easy-\/to-\/use plugin system for creating powerful, fast and versatile parsers and compilers, with built-\/in source-\/map… \href{https://github.com/jonschlinkert/snapdragon}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/snapdragon}{\tt homepage}
\end{DoxyItemize}

\subsubsection*{Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

Please read the .github/contributing.\+md \char`\"{}contributing guide\char`\"{} for advice on opening issues, pull requests, and coding standards.

\subsubsection*{Building docs}

\+\_\+(This project\textquotesingle{}s readme.\+md is generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb}, please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in the .verb.\+md \char`\"{}.\+verb.\+md\char`\"{} readme template.)\+\_\+

To generate the readme, run the following command\+:


\begin{DoxyCode}
$ npm install -g verbose/verb#dev verb-generate-readme && verb
\end{DoxyCode}


\subsubsection*{Running tests}

Running and reviewing unit tests is a great way to get familiarized with a library and its A\+PI. You can install dependencies and run tests with the following command\+:


\begin{DoxyCode}
$ npm install && npm test
\end{DoxyCode}


\subsubsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{https://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsubsection*{License}

Copyright © 2017, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \mbox{[}M\+IT License\mbox{]}(L\+I\+C\+E\+N\+SE).





{\itshape This file was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme}, v0.\+6.\+0, on June 25, 2017.} 